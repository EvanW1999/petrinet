/*globals define, WebGMEGlobal*/

/**
 * Generated by VisualizerGenerator 1.7.0 from webgme on Sat Nov 28 2020 18:49:42 GMT-0500 (Eastern Standard Time).
 */
const TRANSITION_TYPE = "Transitions";
const PLACES_TYPE = "Places";
const NODE_SOURCE = "src";
const NODE_DST = "dst";

define([
  "jointjs",
  "css!jointjscss",
  "css!./styles/PetrinetVisualizationWidget.css",
], function (jointjs) {
  "use strict";

  var WIDGET_CLASS = "petrinet-visualization";

  function PetrinetVisualizationWidget(logger, container, client) {
    this._logger = logger.fork("Widget");

    this._el = container;
    this._client = client;

    this._initialize();

    this._logger.debug("ctor finished");
    console.log("here");
  }

  PetrinetVisualizationWidget.prototype._initialize = function () {
    const width = this._el.width();
    const height = this._el.height();

    // set widget class
    this._el.addClass(WIDGET_CLASS);

    this._graph = new jointjs.dia.Graph();
    this._paper = new jointjs.dia.Paper({
      el: $(this._el),
      width: width,
      height: height,
      gridSize: 1,
      defaultAnchor: { name: "perpendicular" },
      defaultConnectionPoint: { name: "boundary" },
      model: this._graph,
    });

    this._paper.setInteractivity(false);
    this._paper.removeTools();

    this._pn = jointjs.shapes.pn;
    this._componentMap = new Map();
    this._unaddedLinks = new Array();

    // const pReady = new pn.Place({
    //   position: { x: 140, y: 50 },
    //   attrs: {
    //     ".label": {
    //       text: "ready",
    //       fill: "#7c68fc",
    //     },
    //     ".root": {
    //       stroke: "#9586fd",
    //       "stroke-width": 3,
    //     },
    //     ".tokens > circle": {
    //       fill: "#7a7e9b",
    //     },
    //   },
    //   tokens: 1,
    // });
    // // this._graph.addCell([pReady]);

    // Create a dummy header
    this._el.append("<h3>PetrinetVisualization Events:</h3>");

    // Registering to events can be done with jQuery (as normal)
    this._el.on("dblclick", function (event) {
      event.stopPropagation();
      event.preventDefault();
    });
    const place1 = new this._pn.Place({
      position: { x: 100, y: 100 },
      attrs: {
        ".label": {
          text: "testy test",
          fill: "#7c68fc",
        },
        ".root": {
          stroke: "#9586fd",
          "stroke-width": 3,
        },
        ".tokens > circle": {
          fill: "#7a7e9b",
        },
      },
      tokens: 1,
    });
    const trans1 = new this._pn.Transition({
      position: { x: 50, y: 160 },
      attrs: {
        ".label": {
          text: "tran tran",
          fill: "#fe854f",
        },
        ".root": {
          fill: "#9586fd",
          stroke: "#9586fd",
        },
      },
    });
    const place2 = new this._pn.Place({
      position: { x: 3000, y: 10000 },
      attrs: {
        ".label": {
          text: "testy test2",
          fill: "#7c68fc",
        },
        ".root": {
          stroke: "#9586fd",
          "stroke-width": 3,
        },
        ".tokens > circle": {
          fill: "#7a7e9b",
        },
      },
      tokens: 1,
    });

    const link = new this._pn.Link({
      source: {
        id: place1.id,
        selector: ".root",
      },
      target: {
        text: "testy test2",
        selector: ".label",
      },
      attrs: {
        ".connection": {
          fill: "none",
          "stroke-linejoin": "round",
          "stroke-width": "2",
          stroke: "#4b4a67",
        },
      },
    });
    // this._graph.addCell([trans1, place1, place2, link]);
  };

  PetrinetVisualizationWidget.prototype.onWidgetContainerResize = function (
    width,
    height
  ) {
    this._logger.debug("Widget is resizing...");
    if (this._paper) {
      this._paper.setDimensions(width, height);
      this._paper.scaleContentToFit();
    }
  };

  // Adding/Removing/Updating items
  PetrinetVisualizationWidget.prototype.addNode = function (desc) {
    if (desc) {
      var newPnElt;
      //   Add node to a table of nodes
      if (desc.isConnection) {
        const linkNode = this._client.getNode(desc.id);
        const sourceId = linkNode.getOwnPointerId(NODE_SOURCE);
        const dstId = linkNode.getOwnPointerId(NODE_DST);
        if (this._componentMap.has(sourceId) && this._componentMap.has(dstId)) {
          newPnElt = new this._pn.Link({
            source: {
              id: this._componentMap.get(sourceId).id,
              selector: ".root",
            },
            target: {
              id: this._componentMap.get(dstId).id,
              selector: ".root",
            },
            attrs: {
              ".connection": {
                fill: "none",
                "stroke-linejoin": "round",
                "stroke-width": "2",
                stroke: "#4b4a67",
              },
            },
          });
        } else {
          this._unaddedLinks.push(desc);
        }
      } else if (desc.nodeType == TRANSITION_TYPE) {
        newPnElt = new this._pn.Transition({
          position: desc.position,
          attrs: {
            ".label": {
              text: desc.name,
              fill: "#fe854f",
            },
            ".root": {
              fill: "#9586fd",
              stroke: "#9586fd",
            },
          },
        });
      } else if (desc.nodeType == PLACES_TYPE) {
        newPnElt = new this._pn.Place({
          position: desc.position,
          attrs: {
            ".label": {
              text: desc.name,
              fill: "#7c68fc",
            },
            ".root": {
              stroke: "#9586fd",
              "stroke-width": 3,
            },
            ".tokens > circle": {
              fill: "#7a7e9b",
            },
          },
          tokens: 1,
        });
      }
      if (newPnElt) {
        this._componentMap.set(desc.id, newPnElt);
        this._graph.addCell([newPnElt]);
        for (var i = 0; i < this._unaddedLinks.length; ++i) {
          this.addNode(this._unaddedLinks.shift());
        }
      }
    }
  };

  PetrinetVisualizationWidget.prototype.removeNode = function (gmeId) {
    this._el.append('<div>Removing node "' + desc.name + '"</div>');
  };

  PetrinetVisualizationWidget.prototype.updateNode = function (desc) {
    if (desc) {
      this._logger.debug("Updating node:", desc);
      this._el.append('<div>Updating node "' + desc.name + '"</div>');
    }
  };

  /* * * * * * * * Visualizer event handlers * * * * * * * */

  PetrinetVisualizationWidget.prototype.onNodeClick = function (/*id*/) {
    // This currently changes the active node to the given id and
    // this is overridden in the controller.
  };

  PetrinetVisualizationWidget.prototype.onBackgroundDblClick = function () {
    this._el.append("<div>Background was double-clicked!!</div>");
  };

  /* * * * * * * * Visualizer life cycle callbacks * * * * * * * */
  PetrinetVisualizationWidget.prototype.destroy = function () {};

  PetrinetVisualizationWidget.prototype.onActivate = function () {
    this._logger.debug("PetrinetVisualizationWidget has been activated");
  };

  PetrinetVisualizationWidget.prototype.onDeactivate = function () {
    this._logger.debug("PetrinetVisualizationWidget has been deactivated");
  };

  return PetrinetVisualizationWidget;
});
